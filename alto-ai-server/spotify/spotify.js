import spotifyAxios from "./spotifyAxios.js";
import pLimit from "p-limit";
import dotenv from "dotenv"
import spotifyPreviewFinder from "spotify-preview-finder";
import { Song } from "../models/song.js";
import { Playlist } from "../models/playlist.js";
import { User } from "../models/user.js";
import { searchAI } from "../search/aiSearch.js";
import { searchArtist } from "../search/artistSearch.js";
import { searchTrack } from "../search/songSearch.js";

export async function spotifySearch(user, q, type, limit) {
    return await spotifyAxios.get(
      `/v1/search?q=${encodeURIComponent(q)}&type=${type}&limit=${limit}`,
      { user: user }
    );
}

async function getMusicPreview(track) {
  let preview = null;

  // Try Spotify preview first
  try {
    const spotifyPreview = await spotifyPreviewFinder(track.name, track.artists[0].name, 1);
    preview = spotifyPreview?.results?.[0]?.previewUrls?.[0] || null;
  } catch (err) {
    console.warn(`Spotify preview not found for ${track.name}:`, err.message);
  }

  // If no Spotify preview, fallback to iTunes
  if (!preview) {
    try {
      const itunesQuery = encodeURIComponent(`${track.name} ${track.artists[0].name}`);
      const itunesUrl = `https://itunes.apple.com/search?term=${itunesQuery}&entity=song&limit=1`;
      const itunesRes = await fetch(itunesUrl);
      const itunesData = await itunesRes.json();
      preview = itunesData.results[0]?.previewUrl || null;
    } catch (err) {
      console.warn(`iTunes preview not found for ${track.name}:`, err.message);
    }
  }

  return preview;
}

export async function addSongToDB(track) {
  //If Song is in the database return it
  const songData = await Song.findOne({ id: track.id });
  if (songData) {
    return songData;
  }

  const preview = await getMusicPreview(track);
  if (!preview) {
    console.warn(`No preview found for ${track.name}, skipping song.`);
    return null;
  }

  const newSongData = {
    title: track.name,
    artist: track.artists.map(a => a.name).join(", "),
    album: track.album.name,
    uri: track.uri,
    id: track.id,
    image: track.album.images?.[0]?.url || null,
    duration: track.duration_ms,
    preview: preview,
  };

  //Put Song in database
  const song = await Song.create(newSongData).catch(err => {
    console.error(`Failed to save song ${track.name}:`, err.message);
  });

  return song;
}

function takeRandom(arr) {
  const randomIndex = Math.floor(Math.random() * arr.length);
  return arr[randomIndex];
}

async function addTrackToArray(user, playlist, mode) {
  const limit = pLimit(10);
  let searchPromises;
  if (mode === "artist"){
    searchPromises = playlist.map((item) =>
      limit(() => searchArtist(user, item)));
  }
  else if (mode === "specific") {
      searchPromises = playlist.map((item) =>
      limit(() => searchTrack(user, item)));
  } else {
      const usedPlaylists = [];
      searchPromises = playlist.map((item) =>
      limit(() => searchAI(user, item, usedPlaylists)));
  }

  // wait for all results
  const results = await Promise.all(searchPromises);

  if (mode === null || mode === "artist") {
    const validTracks = []
    for (let i = 0; i < results.length; i++) {
      let needToAdd = Math.ceil(10 / results.length);
      let iteration = 0;
      while(needToAdd > 0 && iteration < 20){
        const track = takeRandom(results[i]);
        // console.log("Selected Track: ", track.title ?? "artist", validTracks.map(t => t.title + " - " + t.artist));
        if(track !== null && validTracks.filter(t => t.title === track.title && t.artist === track.artist).length === 0){
          validTracks.push(track);
          needToAdd -= 1;
        }
      }
    }
    return validTracks;
  }
  else{
    const validTracks = results.flat().filter((track) => track !== null);
    return validTracks;
  }
}

async function createPlaylist(user, name) {
  const userId = await User.findById(user._id).then(u => u.spotifyId);  
  const res = await spotifyAxios.post(
    `/v1/users/${userId}/playlists`,
    {
      name: name, // Playlist name
      public: false, // true = public, false = private
      description: "Generated by AltoAI",
    },
    {
      user: user,
    }
  );
  return res.data.id; // Returns the new playlist ID
}

export async function addAllTracksToPlaylist(user, trackURIs, playlistName) {
  try {
    const playlistId = await createPlaylist(user, playlistName);

    // Step 3: add all tracks from array
    const addRes = await spotifyAxios.post(
      `/v1/playlists/${playlistId}/tracks`,
      { uris: trackURIs },
      { user: user },
    );

    console.log("Tracks added:", addRes.status === 201 ? "✅" : "❌");
  } catch (err) {
    console.error(
      "Error creating playlist or adding tracks:",
      err.response?.data || err.message
    );
  }
}

export async function checkValidSongs(user, playlist, mode) {
  console.log("Check Songs: ", playlist);
  const tracks = await addTrackToArray(user, playlist, mode);
  return tracks;
}

// Helper to clean and split the prompt into an array of songs
export function parseSongsFromPrompt(prompt) {
  if (!prompt) return [];
  return prompt
    .split(",")               // split by comma
    .map((s) => s.trim())    // remove extra spaces
    .filter((s) => s.length > 0); // remove empty strings
}

export async function addTracksToDatabase(tracks, user, prompt) {
  const playlist = await Playlist.create({
    user: user._id,
    playlist: tracks.map(track => track._id),
    prompt: prompt
  });


  return playlist;
}
  